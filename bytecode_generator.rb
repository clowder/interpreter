## Our humble bytecode format
#
#                                       Stack
# Opcode           Operands     before         after
CALL,            # index, argc  [rcv, arg...]  [returned]
PUSH_NUMBER,     # index        []             [number]
PUSH_STRING,     # index        []             [string]
PUSH_SELF,       #              []             [self]
PUSH_NIL,        #              []             [nil]
PUSH_BOOL,       # 1=t, 0=f     []             [true or false]
GET_LOCAL,       # index        []             [value]
SET_LOCAL,       # index        [value]        []
JUMP_UNLESS,     # offset       [test]         []
JUMP,            # offset       []             []
ADD,             #              [a, b]         [result]
RETURN = *       #              []             []
(0..11)

class BytecodeGenerator
  def initialize
    @literals = []
    @locals = []
    @instructions = []
  end

  def compile_all(nodes)
    nodes.each do |node|
      node.compile(self)
    end
  end

  def number_literal(value)
    emit PUSH_NUMBER, literal_index(value) # [0] 100, .... [0] 100
  end

  def string_literal(value)
    emit PUSH_STRING, literal_index(value)
  end

  def true_literal
    emit PUSH_BOOL, 1
  end

  def false_literal
    emit PUSH_BOOL, 0
  end

  def nil_literal
    emit PUSH_NIL
  end

  def set_local(name, value)
    value.compile(self)
    emit SET_LOCAL, local_index(name) # a => 0, b => 1 ..... a => 0
  end

  def get_local(name)
    emit GET_LOCAL, local_index(name)
  end

  def call(receiver, method, arguments)
    if receiver
      receiver.compile(self)
    else
      # print("hi")
      # self.print("hi")
      emit PUSH_SELF
    end

    arguments.each do |argument|
      argument.compile(self)
    end

    # Static typing: int a, String s;
    if method == "+" # && and receiver and argument[0] is number
      emit ADD
      return
    end

    emit CALL, literal_index(method), arguments.size
  end

  def if(condition, body, else_body)
    condition.compile(self)
    emit JUMP_UNLESS, 0 # <= offset
    offset_index = @instructions.size - 1
    body.compile(self)
    emit JUMP, 0 if else_body

    # Compute the number of bytes generated by the body
    @instructions[offset_index] = @instructions.size - 1 - offset_index

    if else_body
      offset_index = @instructions.size - 1
      else_body.compile(self)
      @instructions[offset_index] = @instructions.size - 1 - offset_index
    end
  end

  # Returns the index of the local in the local table
  def local_index(name)
    @locals << name unless @locals.include?(name)
    @locals.index(name)
  end

  # Returns the index of the literal in the literal table
  def literal_index(literal)
    @literals << literal unless @literals.include?(literal)
    @literals.index(literal)
  end

  # Emit the instruction
  # Eg.:
  #  emit CALL, 1, 10
  # will generate the bytecode
  # 0, 1, 10
  def emit(opcode, *operands)
    @instructions << opcode
    @instructions.concat operands
  end

  def assemble
    emit RETURN

    {
      :literals => @literals,
      :locals => @locals,
      :instructions => @instructions
    }
  end
end
